%\VignetteIndexEntry{ezsim} 
\documentclass[a4paper]{article}
\usepackage{geometry, amsmath}
\title{A Vignette for the R package: ezsim}
\author{TszKin Julian Chan <ctszkin@gmail.com>}
\begin{document}
\maketitle
\tableofcontents
\section{Introduction}

ezsim provides a handy way to run simulation and examine its results. 
Users dont have to work on those tedious jobs such as loop over several set of parameters, organize and summarize the simulation results,etc. Those tedious jobs are completed by ezsim. Users are only required to define some necessary information, such as data generating process, parameters and estimators. 
In addition, ezsim provides a flexible way to visualize the simulation results and support parallel computing. In this vignette, several examples are used to demonstrate how to create a simulation with ezsim. Our first example will give you a first glance of what ezsim can do for you. Section 2 and 3 will tell you how to use ezsim. \\
Suppose $x_{i}\dots x_{n}$ are drawn independently from a normal distribution with mean $\mu$ and standard deviation $\sigma$. We want to know how the sample size $n$, mean $\mu$ and standard deviation $\sigma$ would affect the behavior of the sample mean.\\
We would like to replicate the simulation for 200 times. $n$ takes value from 20,40,60,80 . $\mu$ takes value from 0,2. $\sigma$ takes value from 1,3,5.

<<keep.source=TRUE,results=hide>>=
library(ezsim)
ezsim_basic<-ezsim(
    m             = 200,
    run           = TRUE,
    core          = 1,
    display_name  = c(mean_hat="hat(mu)",sd_mean_hat="hat(sigma[hat(mu)])"),
    parameter_def = createParDef(list(n=seq(20,80,20),mu=c(0,2),sigma=c(1,3,5))),
    dgp           = function() rnorm(n,mu,sigma),
    estimator     = function(x) c(mean_hat = mean(x), 
                                 sd_mean_hat=sd(x)/sqrt(length(x)-1)),
    true_value    = function() c(mu, sigma / sqrt(n-1))
)
<<>>=
summary(ezsim_basic)
<<eval=FALSE>>=
plot(ezsim_basic)
plot(ezsim_basic,"density")
@
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,return_print=TRUE)[[1]])
@
\\
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,return_print=TRUE)[[2]])
@
\\
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,"density",return_print=TRUE)[[1]])
@
\\
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,"density",return_print=TRUE)[[2]])
@

\section{Pre-simulation}
There are four essential components to build an ezsim object. You must specify each of them to create an \texttt{ezsim} object.
 \begin{enumerate}
    \item Number of Replication $m$ 
    \item Data Generating Process (dgp) : Function for generating data.
    \item Parameters : dgp takes the value of parameters to generate data.
    \item Estimators : It computes the estimates from the data generated by dgp. 
\end{enumerate}
Also there are four optional components, they are:
 \begin{enumerate}
    \item True Value (TV) : It computes the true value of estimates from dgp. 
    \item Display Name : It defines the display format of the name of estimators and parameters. See \texttt{plotmath} in R manual.
    \item run : If it is true, then the simulation will be ran right after the ezsim \item object is created. Otherwise, you can run it manually by \texttt{run(ezsim\_basic)}. Default is \texttt{TRUE}.
    \item core : The number of CPU core to be used in the simulation. It is implemented by \texttt{foreach} and \texttt{doSNOW}. Default is 1.
\end{enumerate}
If you dont specify the value of \texttt{True Value}, the value of \texttt{bias} and \texttt{rmse} will also be \texttt{NA}. 

\subsection{Parameters}
In ezsim, parameters are generated by parameterDef object. To create a parameterDef object, we can use the function createParDef. It takes 2 auguments, \texttt{scalars}(the first argument) and \texttt{others}. \texttt{scalars} are all scalar parameters in the parameters set. Any vectors or matrix are regarded as a sequence of the same parameter. If some of your parameters are vector, matrix or other data types, you need to define it as \texttt{others}. \texttt{others} can take any data type but are fixed in the simulation.\\
In our example, all parameters are scalars. We can create a parameterDef object by:
<<>>=
par_def<-createParDef(scalars=list(n=seq(20,80,20),mu=c(0,2),sigma=c(1,3,5)))
par_def
@
Since we have 4 different values of $n$, 2 different values of $\mu$ and 3 different values of $\sigma$, there is total of $4\times3\times2=24$ possible combination of parameter sets. If we want to have a look of the generated parameters, we can use the function \texttt{generate}. It will return a list of parameter sets. (Only the first three will be shown in the example)
<<>>=
generate(par_def)[1:3]
@
\texttt{setScalars} and \texttt{setOthers} change the value of a parameterDef object. Different from \texttt{createParDef}, the parameters dont have to be store in a list.\\
Example: Suppose we want to generate $n$ sample from a bivariate normal distribution with parameter $\mu_{1}$, $\mu_{2}$ and a variance-covraiance matrix $\Sigma$. 
<<>>=
par_def2<-createParDef(scalars=list(mu1=5,mu2=3,n=c(10,20)), others=list(Sigma=matrix(c(1,.4,.4,1),nrow=2)))
generate(par_def2)
@

\subsection{Data Generating Process}
The Data Generating Process generates the simulated data for \texttt{estimator} to compute the estimates. Inside this function, you can call any parameters directly. It must be a function.\\
In our example, the data generating process very is simple. It generate a vector of normal random variables with length $n$, mean $\mu$ and sd $\sigma$.
<<>>=
dgp<-function(){
	rnorm(n,mu,sigma)
}
@ If you want to test whether a dgp works properly, you can test the dgp and the parameterDef object with \texttt{test}. The \texttt{index} augument specify which parameter set will it use for test. The order of parameters set is the same as the return value of \texttt{generate}. 
<<>>=
test(par_def,dgp,index=1)
test(par_def,dgp,index=2)

@ Similarly, we can test whether \texttt{par_def2} with the following code: 
<<>>=
dgp_2<-function(){
    z1<-rnorm(n)
    z2<-rnorm(n)
    cbind(x1=mu1+z1*Sigma[1,1], x2=mu2+ Sigma[2,2]*(Sigma[1,2]*z1+ sqrt(1-Sigma[1,2]^2)*z2 ))
}
test(par_def2,dgp_2)

@
\subsection{Estimators}
It computes the estimates from the data generated by \texttt{dgp}.  The return value of estimators must be a numeric vector. Dont forget to specify the name of estimators. You can use the \texttt{test} function to test whether the function work properly. It must be a function.
<<>>=
estimator<-function(x){
    c(mean_hat = mean(x), sd_mean_hat=sd(x)/sqrt(length(x)-1))
}
estimator(test(par_def,dgp,index=1))
@

\subsection{True Value}
It computes the true value of estimates from dgp. The return value should have same length as the estimators. Also, the position of return value should match with estimators. Similar to \texttt{dgp}, You can call any parameters within this function. It can be a function or \texttt{NA}(bias and rmse will also be \texttt{NA}). 
<<>>=
true<-function(){
    c(mu, sigma / sqrt(n-1))
}
test(par_def,true)
@

\subsection{Display Name}
It defines the display format of the name of estimators and parameters. For example, you can set the display name of "mean\_hat" to "hat(mu)".  See \texttt{plotmath} for details. 
<<>>=
display_name<-c(mean_hat="hat(mu)",sd_mean_hat="hat(sigma[hat(mu)])")
@   

\section{Post-simulation}
\subsection{Summary Table}
You can create a summary table by \texttt{summary} . The default summary statistics include mean, true value, bias, standard deviation, root mean square error and p-value of Jarque-Bera test. See section 1 for example.
\subsubsection{Subset of the Summary Table}
You can select a subset of parameters and estimators to compute the summary statistics.
<<>>=
summary(ezsim_basic,subset=list(estimator="mean_hat",n=c(20,40),sigma=c(1,3)))
@
\subsubsection{More Summary Statistics}
If you want to have more summary statistics, you can set \texttt{simple=FALSE} in the argument. Then the summary statistics will also include: percentage of bias, minimum, first quartile, median, third quartile and maximum.
<<>>=
summary(ezsim_basic,simple=FALSE,subset=list(estimator="mean_hat",n=c(20,40),sigma=c(1,3)))
@
\subsubsection{Customize the Summary Statistics}
You can choose a subset of summary statistics by specifying value in \texttt{stat}. Also you can define your own summary statistics. \texttt{value\_of\_estimator} is the value of estimator and \texttt{value\_of\_TV} is the value of true value.
<<>>=
summary(ezsim_basic,stat=c("q25","median","q75"),Q025=quantile(value_of_estimator,0.025),Q975=quantile(value_of_estimator,0.975),subset=list(estimator="mean_hat",n=c(20,40),sigma=c(1,3)))
@

\subsection{Plotting the simulation}
\subsubsection{Plotting an ezsim object}
The plot contains the mean, median, true value , 2.5th, 25th, 75th and 97.5th percentile of the estimator. The mean, median, true value are plotted as black, blue and red line respectively. 2.5th and 97.5th percentile form a 95\% confidence bound and 25th and 75th percentile form a 50\% confidence bound.\\
x-axis of the plot will be the parameter with the most number of value. Rest of them will be facets of the plot. Each estimator will occupy one plot. See section 1 for examples.
\subsubsection{Subset of the Plot}
The usage of \texttt{subset} is similar to \texttt{summary}. You can select a subset of \texttt{estimators} and\\or \texttt{parameters}.
<<eval=FALSE>>=
plot(ezsim_basic,subset=list(estimator="sd_mean_hat",mu=3))
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,subset=list(estimator="sd_mean_hat",mu=0),return_print=TRUE)[[1]])

<<eval=FALSE>>=
plot(ezsim_basic,subset=list(estimator="mean_hat",sigma=3))
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,subset=list(estimator="mean_hat",sigma=3),return_print=TRUE)[[1]])
@
\subsubsection{Parameters Priority of the Plot}
The default priority of parameters is sorted by the number of value of each parameter(more to less).  You can reset it by \texttt{parameter\_priority}. The first parameter will have the highest priority(shown in the x-axis). You dont have to specify all parameters, the rest of them are sorted by the number of value of each of them. 

<<eval=FALSE>>=
plot(ezsim_basic,subset=list(estimator="sd_mean_hat",mu=0),parameters_priority=c("sigma","n"))
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,subset=list(estimator="sd_mean_hat",mu=0),parameters_priority="sigma",return_print=TRUE)[[1]])


<<eval=FALSE>>=
plot(ezsim_basic,subset=list(estimator="mean_hat",sigma=c(1,3)),parameters_priority="mu")
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,subset=list(estimator="mean_hat",sigma=c(1,3)),parameters_priority="mu",return_print=TRUE)[[1]])

@
\subsubsection{Density Plot}
Plot the density funtcion of the estimator. \texttt{subset} and \texttt{parameter\_priority} are valid for density plot. You can specify \texttt{benchmark=dnorm} by adding a density of the standard normal distribution. \texttt{dorm} can be replaced by other density function. See section 1 for examples.


<<eval=FALSE>>=
plot(ezsim_basic,"density",subset=list(estimator="mean_hat",sigma=3),parameters_priority="n",benchmark=dnorm)
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,"density",benchmark=dnorm,subset=list(estimator="mean_hat",sigma=3),parameters_priority="n",return_print=TRUE)[[1]])


<<eval=FALSE>>=
plot(ezsim_basic,"density",subset=list(estimator="mean_hat",mu=0),parameters_priority="n" ,benchmark=dnorm)
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ezsim_basic,"density",benchmark=dnorm,subset=list(estimator="mean_hat",mu=0),parameters_priority="n",return_print=TRUE)[[1]])
@



\subsubsection{Plot the summary ezsim}
<<eval=FALSE>>=
plot(summary(ezsim_basic,c("q25","q75")))
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(summary(ezsim_basic,c("q25","q75")),return_print=TRUE))

<<eval=FALSE>>=
plot(summary(ezsim_basic,c("q25","q75"),subset=list(estimator="mean_hat")))
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(summary(ezsim_basic,c("q25","q75"),subset=list(estimator="mean_hat")),return_print=TRUE))

<<eval=FALSE>>=
plot(summary(ezsim_basic,c("median"),subset=list(estimator="sd_mean_hat")))
<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(summary(ezsim_basic,c("median"),subset=list(estimator="sd_mean_hat")),return_print=TRUE))

@

\subsubsection{Plot the Power Function}
If the estimator is an indicator of rejecting a null hypothesis(0: fail to reject null hypothesis; 1: reject null hypothesis), then we can plot the power function. A vertical line will be drawn if \texttt{null\_hypothesis} is specified. The intersection of hte vertical line(value of null hypothesis) and the power function is the size of the test. The following example shows the power function of testing whether the coefficient of a linear model is larger than one with t-test and z-test.

<<results=hide,keep.source=TRUE>>=
ez_powerfun<-ezsim(
    m             = 100,
    run           = TRUE,
    core          = 1,
    display_name  = c(b="beta",es="sigma[e]^2",xs="sigma[x]^2"),
    parameter_def = createParDef(scalars=list(xs=1,n=50,es=5,b=seq(-1,1,0.1))),
    dgp           = function(){
                        x<-rnorm(n,0,xs)
                        e<-rnorm(n,0,es)
                        y<-b * x + e
                        data.frame(y,x)
                    },
    estimator     = function(d){
                        r<-summary(lm(y~x-1,data=d))
                        stat<-r$coef[,1]/r$coef[,2]

                        # test whether b > 0
                        # level of significance : 5%
                        out <- stat > c(qnorm(.95), qt(0.95,df=r$df[2]))
                        names(out)<-c("z-test","t-test")
                        out
                    }
)
@
<<eval=FALSE>>=
plot(ez_powerfun,"powerfun",null_hypothesis=0)

<<fig=TRUE,echo=FALSE,results=hide>>=
print(plot(ez_powerfun,"powerfun",null_hypothesis=0,return_print=TRUE))
@
\end{document}



